// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"github.com/alphagov/paas-auditor/pkg/db"
	"github.com/cloudfoundry-community/go-cfclient"
)

type FakeEventDB struct {
	InitStub        func() error
	initMutex       sync.RWMutex
	initArgsForCall []struct{}
	initReturns     struct {
		result1 error
	}
	initReturnsOnCall map[int]struct {
		result1 error
	}
	StoreCfAuditEventsStub        func(events []cfclient.Event) error
	storeCfAuditEventsMutex       sync.RWMutex
	storeCfAuditEventsArgsForCall []struct {
		events []cfclient.Event
	}
	storeCfAuditEventsReturns struct {
		result1 error
	}
	storeCfAuditEventsReturnsOnCall map[int]struct {
		result1 error
	}
	GetCfAuditEventsStub        func(filter db.RawEventFilter) ([]cfclient.Event, error)
	getCfAuditEventsMutex       sync.RWMutex
	getCfAuditEventsArgsForCall []struct {
		filter db.RawEventFilter
	}
	getCfAuditEventsReturns struct {
		result1 []cfclient.Event
		result2 error
	}
	getCfAuditEventsReturnsOnCall map[int]struct {
		result1 []cfclient.Event
		result2 error
	}
	GetLatestCfEventTimeStub        func() (*time.Time, error)
	getLatestCfEventTimeMutex       sync.RWMutex
	getLatestCfEventTimeArgsForCall []struct{}
	getLatestCfEventTimeReturns     struct {
		result1 *time.Time
		result2 error
	}
	getLatestCfEventTimeReturnsOnCall map[int]struct {
		result1 *time.Time
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeEventDB) Init() error {
	fake.initMutex.Lock()
	ret, specificReturn := fake.initReturnsOnCall[len(fake.initArgsForCall)]
	fake.initArgsForCall = append(fake.initArgsForCall, struct{}{})
	fake.recordInvocation("Init", []interface{}{})
	fake.initMutex.Unlock()
	if fake.InitStub != nil {
		return fake.InitStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.initReturns.result1
}

func (fake *FakeEventDB) InitCallCount() int {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return len(fake.initArgsForCall)
}

func (fake *FakeEventDB) InitReturns(result1 error) {
	fake.InitStub = nil
	fake.initReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventDB) InitReturnsOnCall(i int, result1 error) {
	fake.InitStub = nil
	if fake.initReturnsOnCall == nil {
		fake.initReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventDB) StoreCfAuditEvents(events []cfclient.Event) error {
	var eventsCopy []cfclient.Event
	if events != nil {
		eventsCopy = make([]cfclient.Event, len(events))
		copy(eventsCopy, events)
	}
	fake.storeCfAuditEventsMutex.Lock()
	ret, specificReturn := fake.storeCfAuditEventsReturnsOnCall[len(fake.storeCfAuditEventsArgsForCall)]
	fake.storeCfAuditEventsArgsForCall = append(fake.storeCfAuditEventsArgsForCall, struct {
		events []cfclient.Event
	}{eventsCopy})
	fake.recordInvocation("StoreCfAuditEvents", []interface{}{eventsCopy})
	fake.storeCfAuditEventsMutex.Unlock()
	if fake.StoreCfAuditEventsStub != nil {
		return fake.StoreCfAuditEventsStub(events)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.storeCfAuditEventsReturns.result1
}

func (fake *FakeEventDB) StoreCfAuditEventsCallCount() int {
	fake.storeCfAuditEventsMutex.RLock()
	defer fake.storeCfAuditEventsMutex.RUnlock()
	return len(fake.storeCfAuditEventsArgsForCall)
}

func (fake *FakeEventDB) StoreCfAuditEventsArgsForCall(i int) []cfclient.Event {
	fake.storeCfAuditEventsMutex.RLock()
	defer fake.storeCfAuditEventsMutex.RUnlock()
	return fake.storeCfAuditEventsArgsForCall[i].events
}

func (fake *FakeEventDB) StoreCfAuditEventsReturns(result1 error) {
	fake.StoreCfAuditEventsStub = nil
	fake.storeCfAuditEventsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventDB) StoreCfAuditEventsReturnsOnCall(i int, result1 error) {
	fake.StoreCfAuditEventsStub = nil
	if fake.storeCfAuditEventsReturnsOnCall == nil {
		fake.storeCfAuditEventsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeCfAuditEventsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventDB) GetCfAuditEvents(filter db.RawEventFilter) ([]cfclient.Event, error) {
	fake.getCfAuditEventsMutex.Lock()
	ret, specificReturn := fake.getCfAuditEventsReturnsOnCall[len(fake.getCfAuditEventsArgsForCall)]
	fake.getCfAuditEventsArgsForCall = append(fake.getCfAuditEventsArgsForCall, struct {
		filter db.RawEventFilter
	}{filter})
	fake.recordInvocation("GetCfAuditEvents", []interface{}{filter})
	fake.getCfAuditEventsMutex.Unlock()
	if fake.GetCfAuditEventsStub != nil {
		return fake.GetCfAuditEventsStub(filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getCfAuditEventsReturns.result1, fake.getCfAuditEventsReturns.result2
}

func (fake *FakeEventDB) GetCfAuditEventsCallCount() int {
	fake.getCfAuditEventsMutex.RLock()
	defer fake.getCfAuditEventsMutex.RUnlock()
	return len(fake.getCfAuditEventsArgsForCall)
}

func (fake *FakeEventDB) GetCfAuditEventsArgsForCall(i int) db.RawEventFilter {
	fake.getCfAuditEventsMutex.RLock()
	defer fake.getCfAuditEventsMutex.RUnlock()
	return fake.getCfAuditEventsArgsForCall[i].filter
}

func (fake *FakeEventDB) GetCfAuditEventsReturns(result1 []cfclient.Event, result2 error) {
	fake.GetCfAuditEventsStub = nil
	fake.getCfAuditEventsReturns = struct {
		result1 []cfclient.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeEventDB) GetCfAuditEventsReturnsOnCall(i int, result1 []cfclient.Event, result2 error) {
	fake.GetCfAuditEventsStub = nil
	if fake.getCfAuditEventsReturnsOnCall == nil {
		fake.getCfAuditEventsReturnsOnCall = make(map[int]struct {
			result1 []cfclient.Event
			result2 error
		})
	}
	fake.getCfAuditEventsReturnsOnCall[i] = struct {
		result1 []cfclient.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeEventDB) GetLatestCfEventTime() (*time.Time, error) {
	fake.getLatestCfEventTimeMutex.Lock()
	ret, specificReturn := fake.getLatestCfEventTimeReturnsOnCall[len(fake.getLatestCfEventTimeArgsForCall)]
	fake.getLatestCfEventTimeArgsForCall = append(fake.getLatestCfEventTimeArgsForCall, struct{}{})
	fake.recordInvocation("GetLatestCfEventTime", []interface{}{})
	fake.getLatestCfEventTimeMutex.Unlock()
	if fake.GetLatestCfEventTimeStub != nil {
		return fake.GetLatestCfEventTimeStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getLatestCfEventTimeReturns.result1, fake.getLatestCfEventTimeReturns.result2
}

func (fake *FakeEventDB) GetLatestCfEventTimeCallCount() int {
	fake.getLatestCfEventTimeMutex.RLock()
	defer fake.getLatestCfEventTimeMutex.RUnlock()
	return len(fake.getLatestCfEventTimeArgsForCall)
}

func (fake *FakeEventDB) GetLatestCfEventTimeReturns(result1 *time.Time, result2 error) {
	fake.GetLatestCfEventTimeStub = nil
	fake.getLatestCfEventTimeReturns = struct {
		result1 *time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeEventDB) GetLatestCfEventTimeReturnsOnCall(i int, result1 *time.Time, result2 error) {
	fake.GetLatestCfEventTimeStub = nil
	if fake.getLatestCfEventTimeReturnsOnCall == nil {
		fake.getLatestCfEventTimeReturnsOnCall = make(map[int]struct {
			result1 *time.Time
			result2 error
		})
	}
	fake.getLatestCfEventTimeReturnsOnCall[i] = struct {
		result1 *time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeEventDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	fake.storeCfAuditEventsMutex.RLock()
	defer fake.storeCfAuditEventsMutex.RUnlock()
	fake.getCfAuditEventsMutex.RLock()
	defer fake.getCfAuditEventsMutex.RUnlock()
	fake.getLatestCfEventTimeMutex.RLock()
	defer fake.getLatestCfEventTimeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeEventDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.EventDB = new(FakeEventDB)
