// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
	"time"

	"github.com/alphagov/paas-auditor/pkg/db"
	cfclient "github.com/cloudfoundry-community/go-cfclient"
)

type FakeEventDB struct {
	GetCfAuditEventsStub        func(db.RawEventFilter) ([]cfclient.Event, error)
	getCfAuditEventsMutex       sync.RWMutex
	getCfAuditEventsArgsForCall []struct {
		arg1 db.RawEventFilter
	}
	getCfAuditEventsReturns struct {
		result1 []cfclient.Event
		result2 error
	}
	getCfAuditEventsReturnsOnCall map[int]struct {
		result1 []cfclient.Event
		result2 error
	}
	GetLatestCfEventTimeStub        func() (*time.Time, error)
	getLatestCfEventTimeMutex       sync.RWMutex
	getLatestCfEventTimeArgsForCall []struct {
	}
	getLatestCfEventTimeReturns struct {
		result1 *time.Time
		result2 error
	}
	getLatestCfEventTimeReturnsOnCall map[int]struct {
		result1 *time.Time
		result2 error
	}
	InitStub        func() error
	initMutex       sync.RWMutex
	initArgsForCall []struct {
	}
	initReturns struct {
		result1 error
	}
	initReturnsOnCall map[int]struct {
		result1 error
	}
	StoreCfAuditEventsStub        func([]cfclient.Event) error
	storeCfAuditEventsMutex       sync.RWMutex
	storeCfAuditEventsArgsForCall []struct {
		arg1 []cfclient.Event
	}
	storeCfAuditEventsReturns struct {
		result1 error
	}
	storeCfAuditEventsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeEventDB) GetCfAuditEvents(arg1 db.RawEventFilter) ([]cfclient.Event, error) {
	fake.getCfAuditEventsMutex.Lock()
	ret, specificReturn := fake.getCfAuditEventsReturnsOnCall[len(fake.getCfAuditEventsArgsForCall)]
	fake.getCfAuditEventsArgsForCall = append(fake.getCfAuditEventsArgsForCall, struct {
		arg1 db.RawEventFilter
	}{arg1})
	fake.recordInvocation("GetCfAuditEvents", []interface{}{arg1})
	fake.getCfAuditEventsMutex.Unlock()
	if fake.GetCfAuditEventsStub != nil {
		return fake.GetCfAuditEventsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getCfAuditEventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventDB) GetCfAuditEventsCallCount() int {
	fake.getCfAuditEventsMutex.RLock()
	defer fake.getCfAuditEventsMutex.RUnlock()
	return len(fake.getCfAuditEventsArgsForCall)
}

func (fake *FakeEventDB) GetCfAuditEventsCalls(stub func(db.RawEventFilter) ([]cfclient.Event, error)) {
	fake.getCfAuditEventsMutex.Lock()
	defer fake.getCfAuditEventsMutex.Unlock()
	fake.GetCfAuditEventsStub = stub
}

func (fake *FakeEventDB) GetCfAuditEventsArgsForCall(i int) db.RawEventFilter {
	fake.getCfAuditEventsMutex.RLock()
	defer fake.getCfAuditEventsMutex.RUnlock()
	argsForCall := fake.getCfAuditEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventDB) GetCfAuditEventsReturns(result1 []cfclient.Event, result2 error) {
	fake.getCfAuditEventsMutex.Lock()
	defer fake.getCfAuditEventsMutex.Unlock()
	fake.GetCfAuditEventsStub = nil
	fake.getCfAuditEventsReturns = struct {
		result1 []cfclient.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeEventDB) GetCfAuditEventsReturnsOnCall(i int, result1 []cfclient.Event, result2 error) {
	fake.getCfAuditEventsMutex.Lock()
	defer fake.getCfAuditEventsMutex.Unlock()
	fake.GetCfAuditEventsStub = nil
	if fake.getCfAuditEventsReturnsOnCall == nil {
		fake.getCfAuditEventsReturnsOnCall = make(map[int]struct {
			result1 []cfclient.Event
			result2 error
		})
	}
	fake.getCfAuditEventsReturnsOnCall[i] = struct {
		result1 []cfclient.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeEventDB) GetLatestCfEventTime() (*time.Time, error) {
	fake.getLatestCfEventTimeMutex.Lock()
	ret, specificReturn := fake.getLatestCfEventTimeReturnsOnCall[len(fake.getLatestCfEventTimeArgsForCall)]
	fake.getLatestCfEventTimeArgsForCall = append(fake.getLatestCfEventTimeArgsForCall, struct {
	}{})
	fake.recordInvocation("GetLatestCfEventTime", []interface{}{})
	fake.getLatestCfEventTimeMutex.Unlock()
	if fake.GetLatestCfEventTimeStub != nil {
		return fake.GetLatestCfEventTimeStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getLatestCfEventTimeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventDB) GetLatestCfEventTimeCallCount() int {
	fake.getLatestCfEventTimeMutex.RLock()
	defer fake.getLatestCfEventTimeMutex.RUnlock()
	return len(fake.getLatestCfEventTimeArgsForCall)
}

func (fake *FakeEventDB) GetLatestCfEventTimeCalls(stub func() (*time.Time, error)) {
	fake.getLatestCfEventTimeMutex.Lock()
	defer fake.getLatestCfEventTimeMutex.Unlock()
	fake.GetLatestCfEventTimeStub = stub
}

func (fake *FakeEventDB) GetLatestCfEventTimeReturns(result1 *time.Time, result2 error) {
	fake.getLatestCfEventTimeMutex.Lock()
	defer fake.getLatestCfEventTimeMutex.Unlock()
	fake.GetLatestCfEventTimeStub = nil
	fake.getLatestCfEventTimeReturns = struct {
		result1 *time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeEventDB) GetLatestCfEventTimeReturnsOnCall(i int, result1 *time.Time, result2 error) {
	fake.getLatestCfEventTimeMutex.Lock()
	defer fake.getLatestCfEventTimeMutex.Unlock()
	fake.GetLatestCfEventTimeStub = nil
	if fake.getLatestCfEventTimeReturnsOnCall == nil {
		fake.getLatestCfEventTimeReturnsOnCall = make(map[int]struct {
			result1 *time.Time
			result2 error
		})
	}
	fake.getLatestCfEventTimeReturnsOnCall[i] = struct {
		result1 *time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeEventDB) Init() error {
	fake.initMutex.Lock()
	ret, specificReturn := fake.initReturnsOnCall[len(fake.initArgsForCall)]
	fake.initArgsForCall = append(fake.initArgsForCall, struct {
	}{})
	fake.recordInvocation("Init", []interface{}{})
	fake.initMutex.Unlock()
	if fake.InitStub != nil {
		return fake.InitStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.initReturns
	return fakeReturns.result1
}

func (fake *FakeEventDB) InitCallCount() int {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return len(fake.initArgsForCall)
}

func (fake *FakeEventDB) InitCalls(stub func() error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = stub
}

func (fake *FakeEventDB) InitReturns(result1 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	fake.initReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventDB) InitReturnsOnCall(i int, result1 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	if fake.initReturnsOnCall == nil {
		fake.initReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventDB) StoreCfAuditEvents(arg1 []cfclient.Event) error {
	var arg1Copy []cfclient.Event
	if arg1 != nil {
		arg1Copy = make([]cfclient.Event, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.storeCfAuditEventsMutex.Lock()
	ret, specificReturn := fake.storeCfAuditEventsReturnsOnCall[len(fake.storeCfAuditEventsArgsForCall)]
	fake.storeCfAuditEventsArgsForCall = append(fake.storeCfAuditEventsArgsForCall, struct {
		arg1 []cfclient.Event
	}{arg1Copy})
	fake.recordInvocation("StoreCfAuditEvents", []interface{}{arg1Copy})
	fake.storeCfAuditEventsMutex.Unlock()
	if fake.StoreCfAuditEventsStub != nil {
		return fake.StoreCfAuditEventsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.storeCfAuditEventsReturns
	return fakeReturns.result1
}

func (fake *FakeEventDB) StoreCfAuditEventsCallCount() int {
	fake.storeCfAuditEventsMutex.RLock()
	defer fake.storeCfAuditEventsMutex.RUnlock()
	return len(fake.storeCfAuditEventsArgsForCall)
}

func (fake *FakeEventDB) StoreCfAuditEventsCalls(stub func([]cfclient.Event) error) {
	fake.storeCfAuditEventsMutex.Lock()
	defer fake.storeCfAuditEventsMutex.Unlock()
	fake.StoreCfAuditEventsStub = stub
}

func (fake *FakeEventDB) StoreCfAuditEventsArgsForCall(i int) []cfclient.Event {
	fake.storeCfAuditEventsMutex.RLock()
	defer fake.storeCfAuditEventsMutex.RUnlock()
	argsForCall := fake.storeCfAuditEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventDB) StoreCfAuditEventsReturns(result1 error) {
	fake.storeCfAuditEventsMutex.Lock()
	defer fake.storeCfAuditEventsMutex.Unlock()
	fake.StoreCfAuditEventsStub = nil
	fake.storeCfAuditEventsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventDB) StoreCfAuditEventsReturnsOnCall(i int, result1 error) {
	fake.storeCfAuditEventsMutex.Lock()
	defer fake.storeCfAuditEventsMutex.Unlock()
	fake.StoreCfAuditEventsStub = nil
	if fake.storeCfAuditEventsReturnsOnCall == nil {
		fake.storeCfAuditEventsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeCfAuditEventsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getCfAuditEventsMutex.RLock()
	defer fake.getCfAuditEventsMutex.RUnlock()
	fake.getLatestCfEventTimeMutex.RLock()
	defer fake.getLatestCfEventTimeMutex.RUnlock()
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	fake.storeCfAuditEventsMutex.RLock()
	defer fake.storeCfAuditEventsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeEventDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.EventDB = new(FakeEventDB)
