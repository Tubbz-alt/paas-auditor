package auth

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	jwt "github.com/dgrijalva/jwt-go"
	"github.com/labstack/echo"
	"golang.org/x/oauth2"
)

type Claims struct {
	Val string `json:"val"`
	jwt.StandardClaims
}

type UAA struct {
	Config *oauth2.Config
}

func (uaa *UAA) Authorize(c echo.Context) error {
	stateToken, err := uaa.createSignedValue(uaa.Config.ClientID)
	if err != nil {
		return err
	}
	authURL := uaa.Config.AuthCodeURL(stateToken)
	return c.Redirect(http.StatusFound, authURL)
}

func (uaa *UAA) Exchange(c echo.Context) error {
	clientID, err := uaa.getSignedValue(c.QueryParam("state"))
	if err != nil {
		return err
	}
	if clientID != uaa.Config.ClientID {
		return errors.New("state token was not generated by this client")
	}
	queryErr := c.QueryParam("error")
	if queryErr != "" {
		return fmt.Errorf("%s: %s", queryErr, c.QueryParam("error_description"))
	}
	authCode := c.QueryParam("code")
	if authCode == "" {
		return errors.New("missing auth code")
	}
	tok, err := uaa.Config.Exchange(context.TODO(), authCode)
	if err != nil {
		return err
	}
	if strings.ToLower(tok.Type()) != "bearer" {
		return errors.New("unexpected token type")
	}
	acceptHeader := c.Request().Header.Get(echo.HeaderAccept)
	accepts := strings.Split(acceptHeader, ",")
	for _, accept := range accepts {
		if accept == echo.MIMEApplicationJSON || accept == echo.MIMEApplicationJSONCharsetUTF8 {
			c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
			return c.JSON(http.StatusOK, fmt.Sprintf(`{"access_token": "%s"}`, tok.AccessToken))
		}
	}
	c.Response().Header().Set(echo.HeaderContentType, echo.MIMETextHTMLCharsetUTF8)
	c.SetCookie(&http.Cookie{
		Name:    CookieAuthorization,
		Value:   tok.AccessToken,
		Expires: time.Now().Add(12 * time.Hour),
		Path:    "/",
	})
	return c.Redirect(http.StatusFound, "/")
}

func (uaa *UAA) NewAuthorizer(token string) (Authorizer, error) {
	if token == "" {
		return nil, errors.New("no auth token: unauthozed")
	}
	return &ClientAuthorizer{
		endpoint: uaa.Config.Endpoint.TokenURL,
		token:    token,
	}, nil
}

// createSignedValue creates a signed string that can be checked with validateStateToken
func (uaa *UAA) createSignedValue(val string) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, Claims{
		uaa.Config.ClientID,
		jwt.StandardClaims{
			ExpiresAt: time.Now().Add(12 * time.Hour).Unix(),
			Issuer:    uaa.Config.ClientID,
		},
	})
	return token.SignedString([]byte(uaa.Config.ClientSecret))
}

// validateStateToken verifies that stateToken was created by generateStateToken
func (uaa *UAA) getSignedValue(tokenString string) (string, error) {
	if tokenString == "" {
		return "", errors.New("token string was empty")
	}
	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("unexpected signing method")
		}
		return []byte(uaa.Config.ClientSecret), nil
	})
	if err != nil {
		if ve, ok := err.(*jwt.ValidationError); ok {
			if ve.Errors&jwt.ValidationErrorMalformed != 0 {
				return "", errors.New("malfored token")
			} else if ve.Errors&(jwt.ValidationErrorExpired|jwt.ValidationErrorNotValidYet) != 0 {
				return "", errors.New("token expired")
			}
		}
		return "", err
	}
	if !token.Valid {
		return "", errors.New("invalid state token")
	}
	claims, ok := token.Claims.(*Claims)
	if !ok {
		return "", fmt.Errorf("unexpected claims type %T", token.Claims)
	}
	if claims.Val == "" {
		return "", errors.New("Unexpected val in claims")
	}
	return claims.Val, nil
}
