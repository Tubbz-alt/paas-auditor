// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/alphagov/paas-billing/store"
)

type FakeEventStorer struct {
	StoreEventsStub        func(events []store.RawEvent) error
	storeEventsMutex       sync.RWMutex
	storeEventsArgsForCall []struct {
		events []store.RawEvent
	}
	storeEventsReturns struct {
		result1 error
	}
	storeEventsReturnsOnCall map[int]struct {
		result1 error
	}
	GetEventsStub        func(filter store.RawEventFilter) ([]store.RawEvent, error)
	getEventsMutex       sync.RWMutex
	getEventsArgsForCall []struct {
		filter store.RawEventFilter
	}
	getEventsReturns struct {
		result1 []store.RawEvent
		result2 error
	}
	getEventsReturnsOnCall map[int]struct {
		result1 []store.RawEvent
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeEventStorer) StoreEvents(events []store.RawEvent) error {
	var eventsCopy []store.RawEvent
	if events != nil {
		eventsCopy = make([]store.RawEvent, len(events))
		copy(eventsCopy, events)
	}
	fake.storeEventsMutex.Lock()
	ret, specificReturn := fake.storeEventsReturnsOnCall[len(fake.storeEventsArgsForCall)]
	fake.storeEventsArgsForCall = append(fake.storeEventsArgsForCall, struct {
		events []store.RawEvent
	}{eventsCopy})
	fake.recordInvocation("StoreEvents", []interface{}{eventsCopy})
	fake.storeEventsMutex.Unlock()
	if fake.StoreEventsStub != nil {
		return fake.StoreEventsStub(events)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.storeEventsReturns.result1
}

func (fake *FakeEventStorer) StoreEventsCallCount() int {
	fake.storeEventsMutex.RLock()
	defer fake.storeEventsMutex.RUnlock()
	return len(fake.storeEventsArgsForCall)
}

func (fake *FakeEventStorer) StoreEventsArgsForCall(i int) []store.RawEvent {
	fake.storeEventsMutex.RLock()
	defer fake.storeEventsMutex.RUnlock()
	return fake.storeEventsArgsForCall[i].events
}

func (fake *FakeEventStorer) StoreEventsReturns(result1 error) {
	fake.StoreEventsStub = nil
	fake.storeEventsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStorer) StoreEventsReturnsOnCall(i int, result1 error) {
	fake.StoreEventsStub = nil
	if fake.storeEventsReturnsOnCall == nil {
		fake.storeEventsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeEventsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStorer) GetEvents(filter store.RawEventFilter) ([]store.RawEvent, error) {
	fake.getEventsMutex.Lock()
	ret, specificReturn := fake.getEventsReturnsOnCall[len(fake.getEventsArgsForCall)]
	fake.getEventsArgsForCall = append(fake.getEventsArgsForCall, struct {
		filter store.RawEventFilter
	}{filter})
	fake.recordInvocation("GetEvents", []interface{}{filter})
	fake.getEventsMutex.Unlock()
	if fake.GetEventsStub != nil {
		return fake.GetEventsStub(filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getEventsReturns.result1, fake.getEventsReturns.result2
}

func (fake *FakeEventStorer) GetEventsCallCount() int {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	return len(fake.getEventsArgsForCall)
}

func (fake *FakeEventStorer) GetEventsArgsForCall(i int) store.RawEventFilter {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	return fake.getEventsArgsForCall[i].filter
}

func (fake *FakeEventStorer) GetEventsReturns(result1 []store.RawEvent, result2 error) {
	fake.GetEventsStub = nil
	fake.getEventsReturns = struct {
		result1 []store.RawEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStorer) GetEventsReturnsOnCall(i int, result1 []store.RawEvent, result2 error) {
	fake.GetEventsStub = nil
	if fake.getEventsReturnsOnCall == nil {
		fake.getEventsReturnsOnCall = make(map[int]struct {
			result1 []store.RawEvent
			result2 error
		})
	}
	fake.getEventsReturnsOnCall[i] = struct {
		result1 []store.RawEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStorer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.storeEventsMutex.RLock()
	defer fake.storeEventsMutex.RUnlock()
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeEventStorer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ store.EventStorer = new(FakeEventStorer)
