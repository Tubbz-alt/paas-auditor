// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/alphagov/paas-billing/eventio"
)

type FakeEventStore struct {
	InitStub        func() error
	initMutex       sync.RWMutex
	initArgsForCall []struct{}
	initReturns     struct {
		result1 error
	}
	initReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshStub        func() error
	refreshMutex       sync.RWMutex
	refreshArgsForCall []struct{}
	refreshReturns     struct {
		result1 error
	}
	refreshReturnsOnCall map[int]struct {
		result1 error
	}
	GetPricingPlansStub        func(filter eventio.PricingPlanFilter) ([]eventio.PricingPlan, error)
	getPricingPlansMutex       sync.RWMutex
	getPricingPlansArgsForCall []struct {
		filter eventio.PricingPlanFilter
	}
	getPricingPlansReturns struct {
		result1 []eventio.PricingPlan
		result2 error
	}
	getPricingPlansReturnsOnCall map[int]struct {
		result1 []eventio.PricingPlan
		result2 error
	}
	StoreEventsStub        func(events []eventio.RawEvent) error
	storeEventsMutex       sync.RWMutex
	storeEventsArgsForCall []struct {
		events []eventio.RawEvent
	}
	storeEventsReturns struct {
		result1 error
	}
	storeEventsReturnsOnCall map[int]struct {
		result1 error
	}
	GetEventsStub        func(filter eventio.RawEventFilter) ([]eventio.RawEvent, error)
	getEventsMutex       sync.RWMutex
	getEventsArgsForCall []struct {
		filter eventio.RawEventFilter
	}
	getEventsReturns struct {
		result1 []eventio.RawEvent
		result2 error
	}
	getEventsReturnsOnCall map[int]struct {
		result1 []eventio.RawEvent
		result2 error
	}
	GetUsageEventRowsStub        func(filter eventio.EventFilter) (eventio.UsageEventRows, error)
	getUsageEventRowsMutex       sync.RWMutex
	getUsageEventRowsArgsForCall []struct {
		filter eventio.EventFilter
	}
	getUsageEventRowsReturns struct {
		result1 eventio.UsageEventRows
		result2 error
	}
	getUsageEventRowsReturnsOnCall map[int]struct {
		result1 eventio.UsageEventRows
		result2 error
	}
	GetUsageEventsStub        func(filter eventio.EventFilter) ([]eventio.UsageEvent, error)
	getUsageEventsMutex       sync.RWMutex
	getUsageEventsArgsForCall []struct {
		filter eventio.EventFilter
	}
	getUsageEventsReturns struct {
		result1 []eventio.UsageEvent
		result2 error
	}
	getUsageEventsReturnsOnCall map[int]struct {
		result1 []eventio.UsageEvent
		result2 error
	}
	GetBillableEventRowsStub        func(ctx context.Context, filter eventio.EventFilter) (eventio.BillableEventRows, error)
	getBillableEventRowsMutex       sync.RWMutex
	getBillableEventRowsArgsForCall []struct {
		ctx    context.Context
		filter eventio.EventFilter
	}
	getBillableEventRowsReturns struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	getBillableEventRowsReturnsOnCall map[int]struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	GetBillableEventsStub        func(filter eventio.EventFilter) ([]eventio.BillableEvent, error)
	getBillableEventsMutex       sync.RWMutex
	getBillableEventsArgsForCall []struct {
		filter eventio.EventFilter
	}
	getBillableEventsReturns struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	getBillableEventsReturnsOnCall map[int]struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	ForecastBillableEventRowsStub        func(ctx context.Context, events []eventio.UsageEvent, filter eventio.EventFilter) (eventio.BillableEventRows, error)
	forecastBillableEventRowsMutex       sync.RWMutex
	forecastBillableEventRowsArgsForCall []struct {
		ctx    context.Context
		events []eventio.UsageEvent
		filter eventio.EventFilter
	}
	forecastBillableEventRowsReturns struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	forecastBillableEventRowsReturnsOnCall map[int]struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	ForecastBillableEventsStub        func(events []eventio.UsageEvent, filter eventio.EventFilter) ([]eventio.BillableEvent, error)
	forecastBillableEventsMutex       sync.RWMutex
	forecastBillableEventsArgsForCall []struct {
		events []eventio.UsageEvent
		filter eventio.EventFilter
	}
	forecastBillableEventsReturns struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	forecastBillableEventsReturnsOnCall map[int]struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	GetConsolidatedBillableEventRowsStub        func(ctx context.Context, filter eventio.EventFilter) (eventio.BillableEventRows, error)
	getConsolidatedBillableEventRowsMutex       sync.RWMutex
	getConsolidatedBillableEventRowsArgsForCall []struct {
		ctx    context.Context
		filter eventio.EventFilter
	}
	getConsolidatedBillableEventRowsReturns struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	getConsolidatedBillableEventRowsReturnsOnCall map[int]struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	GetConsolidatedBillableEventsStub        func(filter eventio.EventFilter) ([]eventio.BillableEvent, error)
	getConsolidatedBillableEventsMutex       sync.RWMutex
	getConsolidatedBillableEventsArgsForCall []struct {
		filter eventio.EventFilter
	}
	getConsolidatedBillableEventsReturns struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	getConsolidatedBillableEventsReturnsOnCall map[int]struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	IsRangeConsolidatedStub        func(filter eventio.EventFilter) (bool, error)
	isRangeConsolidatedMutex       sync.RWMutex
	isRangeConsolidatedArgsForCall []struct {
		filter eventio.EventFilter
	}
	isRangeConsolidatedReturns struct {
		result1 bool
		result2 error
	}
	isRangeConsolidatedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ConsolidateAllStub        func() error
	consolidateAllMutex       sync.RWMutex
	consolidateAllArgsForCall []struct{}
	consolidateAllReturns     struct {
		result1 error
	}
	consolidateAllReturnsOnCall map[int]struct {
		result1 error
	}
	ConsolidateFullMonthsStub        func(startAt string, endAt string) error
	consolidateFullMonthsMutex       sync.RWMutex
	consolidateFullMonthsArgsForCall []struct {
		startAt string
		endAt   string
	}
	consolidateFullMonthsReturns struct {
		result1 error
	}
	consolidateFullMonthsReturnsOnCall map[int]struct {
		result1 error
	}
	ConsolidateStub        func(filter eventio.EventFilter) error
	consolidateMutex       sync.RWMutex
	consolidateArgsForCall []struct {
		filter eventio.EventFilter
	}
	consolidateReturns struct {
		result1 error
	}
	consolidateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeEventStore) Init() error {
	fake.initMutex.Lock()
	ret, specificReturn := fake.initReturnsOnCall[len(fake.initArgsForCall)]
	fake.initArgsForCall = append(fake.initArgsForCall, struct{}{})
	fake.recordInvocation("Init", []interface{}{})
	fake.initMutex.Unlock()
	if fake.InitStub != nil {
		return fake.InitStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.initReturns.result1
}

func (fake *FakeEventStore) InitCallCount() int {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return len(fake.initArgsForCall)
}

func (fake *FakeEventStore) InitReturns(result1 error) {
	fake.InitStub = nil
	fake.initReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) InitReturnsOnCall(i int, result1 error) {
	fake.InitStub = nil
	if fake.initReturnsOnCall == nil {
		fake.initReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) Refresh() error {
	fake.refreshMutex.Lock()
	ret, specificReturn := fake.refreshReturnsOnCall[len(fake.refreshArgsForCall)]
	fake.refreshArgsForCall = append(fake.refreshArgsForCall, struct{}{})
	fake.recordInvocation("Refresh", []interface{}{})
	fake.refreshMutex.Unlock()
	if fake.RefreshStub != nil {
		return fake.RefreshStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.refreshReturns.result1
}

func (fake *FakeEventStore) RefreshCallCount() int {
	fake.refreshMutex.RLock()
	defer fake.refreshMutex.RUnlock()
	return len(fake.refreshArgsForCall)
}

func (fake *FakeEventStore) RefreshReturns(result1 error) {
	fake.RefreshStub = nil
	fake.refreshReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) RefreshReturnsOnCall(i int, result1 error) {
	fake.RefreshStub = nil
	if fake.refreshReturnsOnCall == nil {
		fake.refreshReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.refreshReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) GetPricingPlans(filter eventio.PricingPlanFilter) ([]eventio.PricingPlan, error) {
	fake.getPricingPlansMutex.Lock()
	ret, specificReturn := fake.getPricingPlansReturnsOnCall[len(fake.getPricingPlansArgsForCall)]
	fake.getPricingPlansArgsForCall = append(fake.getPricingPlansArgsForCall, struct {
		filter eventio.PricingPlanFilter
	}{filter})
	fake.recordInvocation("GetPricingPlans", []interface{}{filter})
	fake.getPricingPlansMutex.Unlock()
	if fake.GetPricingPlansStub != nil {
		return fake.GetPricingPlansStub(filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getPricingPlansReturns.result1, fake.getPricingPlansReturns.result2
}

func (fake *FakeEventStore) GetPricingPlansCallCount() int {
	fake.getPricingPlansMutex.RLock()
	defer fake.getPricingPlansMutex.RUnlock()
	return len(fake.getPricingPlansArgsForCall)
}

func (fake *FakeEventStore) GetPricingPlansArgsForCall(i int) eventio.PricingPlanFilter {
	fake.getPricingPlansMutex.RLock()
	defer fake.getPricingPlansMutex.RUnlock()
	return fake.getPricingPlansArgsForCall[i].filter
}

func (fake *FakeEventStore) GetPricingPlansReturns(result1 []eventio.PricingPlan, result2 error) {
	fake.GetPricingPlansStub = nil
	fake.getPricingPlansReturns = struct {
		result1 []eventio.PricingPlan
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetPricingPlansReturnsOnCall(i int, result1 []eventio.PricingPlan, result2 error) {
	fake.GetPricingPlansStub = nil
	if fake.getPricingPlansReturnsOnCall == nil {
		fake.getPricingPlansReturnsOnCall = make(map[int]struct {
			result1 []eventio.PricingPlan
			result2 error
		})
	}
	fake.getPricingPlansReturnsOnCall[i] = struct {
		result1 []eventio.PricingPlan
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) StoreEvents(events []eventio.RawEvent) error {
	var eventsCopy []eventio.RawEvent
	if events != nil {
		eventsCopy = make([]eventio.RawEvent, len(events))
		copy(eventsCopy, events)
	}
	fake.storeEventsMutex.Lock()
	ret, specificReturn := fake.storeEventsReturnsOnCall[len(fake.storeEventsArgsForCall)]
	fake.storeEventsArgsForCall = append(fake.storeEventsArgsForCall, struct {
		events []eventio.RawEvent
	}{eventsCopy})
	fake.recordInvocation("StoreEvents", []interface{}{eventsCopy})
	fake.storeEventsMutex.Unlock()
	if fake.StoreEventsStub != nil {
		return fake.StoreEventsStub(events)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.storeEventsReturns.result1
}

func (fake *FakeEventStore) StoreEventsCallCount() int {
	fake.storeEventsMutex.RLock()
	defer fake.storeEventsMutex.RUnlock()
	return len(fake.storeEventsArgsForCall)
}

func (fake *FakeEventStore) StoreEventsArgsForCall(i int) []eventio.RawEvent {
	fake.storeEventsMutex.RLock()
	defer fake.storeEventsMutex.RUnlock()
	return fake.storeEventsArgsForCall[i].events
}

func (fake *FakeEventStore) StoreEventsReturns(result1 error) {
	fake.StoreEventsStub = nil
	fake.storeEventsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) StoreEventsReturnsOnCall(i int, result1 error) {
	fake.StoreEventsStub = nil
	if fake.storeEventsReturnsOnCall == nil {
		fake.storeEventsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeEventsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) GetEvents(filter eventio.RawEventFilter) ([]eventio.RawEvent, error) {
	fake.getEventsMutex.Lock()
	ret, specificReturn := fake.getEventsReturnsOnCall[len(fake.getEventsArgsForCall)]
	fake.getEventsArgsForCall = append(fake.getEventsArgsForCall, struct {
		filter eventio.RawEventFilter
	}{filter})
	fake.recordInvocation("GetEvents", []interface{}{filter})
	fake.getEventsMutex.Unlock()
	if fake.GetEventsStub != nil {
		return fake.GetEventsStub(filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getEventsReturns.result1, fake.getEventsReturns.result2
}

func (fake *FakeEventStore) GetEventsCallCount() int {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	return len(fake.getEventsArgsForCall)
}

func (fake *FakeEventStore) GetEventsArgsForCall(i int) eventio.RawEventFilter {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	return fake.getEventsArgsForCall[i].filter
}

func (fake *FakeEventStore) GetEventsReturns(result1 []eventio.RawEvent, result2 error) {
	fake.GetEventsStub = nil
	fake.getEventsReturns = struct {
		result1 []eventio.RawEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetEventsReturnsOnCall(i int, result1 []eventio.RawEvent, result2 error) {
	fake.GetEventsStub = nil
	if fake.getEventsReturnsOnCall == nil {
		fake.getEventsReturnsOnCall = make(map[int]struct {
			result1 []eventio.RawEvent
			result2 error
		})
	}
	fake.getEventsReturnsOnCall[i] = struct {
		result1 []eventio.RawEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetUsageEventRows(filter eventio.EventFilter) (eventio.UsageEventRows, error) {
	fake.getUsageEventRowsMutex.Lock()
	ret, specificReturn := fake.getUsageEventRowsReturnsOnCall[len(fake.getUsageEventRowsArgsForCall)]
	fake.getUsageEventRowsArgsForCall = append(fake.getUsageEventRowsArgsForCall, struct {
		filter eventio.EventFilter
	}{filter})
	fake.recordInvocation("GetUsageEventRows", []interface{}{filter})
	fake.getUsageEventRowsMutex.Unlock()
	if fake.GetUsageEventRowsStub != nil {
		return fake.GetUsageEventRowsStub(filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getUsageEventRowsReturns.result1, fake.getUsageEventRowsReturns.result2
}

func (fake *FakeEventStore) GetUsageEventRowsCallCount() int {
	fake.getUsageEventRowsMutex.RLock()
	defer fake.getUsageEventRowsMutex.RUnlock()
	return len(fake.getUsageEventRowsArgsForCall)
}

func (fake *FakeEventStore) GetUsageEventRowsArgsForCall(i int) eventio.EventFilter {
	fake.getUsageEventRowsMutex.RLock()
	defer fake.getUsageEventRowsMutex.RUnlock()
	return fake.getUsageEventRowsArgsForCall[i].filter
}

func (fake *FakeEventStore) GetUsageEventRowsReturns(result1 eventio.UsageEventRows, result2 error) {
	fake.GetUsageEventRowsStub = nil
	fake.getUsageEventRowsReturns = struct {
		result1 eventio.UsageEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetUsageEventRowsReturnsOnCall(i int, result1 eventio.UsageEventRows, result2 error) {
	fake.GetUsageEventRowsStub = nil
	if fake.getUsageEventRowsReturnsOnCall == nil {
		fake.getUsageEventRowsReturnsOnCall = make(map[int]struct {
			result1 eventio.UsageEventRows
			result2 error
		})
	}
	fake.getUsageEventRowsReturnsOnCall[i] = struct {
		result1 eventio.UsageEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetUsageEvents(filter eventio.EventFilter) ([]eventio.UsageEvent, error) {
	fake.getUsageEventsMutex.Lock()
	ret, specificReturn := fake.getUsageEventsReturnsOnCall[len(fake.getUsageEventsArgsForCall)]
	fake.getUsageEventsArgsForCall = append(fake.getUsageEventsArgsForCall, struct {
		filter eventio.EventFilter
	}{filter})
	fake.recordInvocation("GetUsageEvents", []interface{}{filter})
	fake.getUsageEventsMutex.Unlock()
	if fake.GetUsageEventsStub != nil {
		return fake.GetUsageEventsStub(filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getUsageEventsReturns.result1, fake.getUsageEventsReturns.result2
}

func (fake *FakeEventStore) GetUsageEventsCallCount() int {
	fake.getUsageEventsMutex.RLock()
	defer fake.getUsageEventsMutex.RUnlock()
	return len(fake.getUsageEventsArgsForCall)
}

func (fake *FakeEventStore) GetUsageEventsArgsForCall(i int) eventio.EventFilter {
	fake.getUsageEventsMutex.RLock()
	defer fake.getUsageEventsMutex.RUnlock()
	return fake.getUsageEventsArgsForCall[i].filter
}

func (fake *FakeEventStore) GetUsageEventsReturns(result1 []eventio.UsageEvent, result2 error) {
	fake.GetUsageEventsStub = nil
	fake.getUsageEventsReturns = struct {
		result1 []eventio.UsageEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetUsageEventsReturnsOnCall(i int, result1 []eventio.UsageEvent, result2 error) {
	fake.GetUsageEventsStub = nil
	if fake.getUsageEventsReturnsOnCall == nil {
		fake.getUsageEventsReturnsOnCall = make(map[int]struct {
			result1 []eventio.UsageEvent
			result2 error
		})
	}
	fake.getUsageEventsReturnsOnCall[i] = struct {
		result1 []eventio.UsageEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetBillableEventRows(ctx context.Context, filter eventio.EventFilter) (eventio.BillableEventRows, error) {
	fake.getBillableEventRowsMutex.Lock()
	ret, specificReturn := fake.getBillableEventRowsReturnsOnCall[len(fake.getBillableEventRowsArgsForCall)]
	fake.getBillableEventRowsArgsForCall = append(fake.getBillableEventRowsArgsForCall, struct {
		ctx    context.Context
		filter eventio.EventFilter
	}{ctx, filter})
	fake.recordInvocation("GetBillableEventRows", []interface{}{ctx, filter})
	fake.getBillableEventRowsMutex.Unlock()
	if fake.GetBillableEventRowsStub != nil {
		return fake.GetBillableEventRowsStub(ctx, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBillableEventRowsReturns.result1, fake.getBillableEventRowsReturns.result2
}

func (fake *FakeEventStore) GetBillableEventRowsCallCount() int {
	fake.getBillableEventRowsMutex.RLock()
	defer fake.getBillableEventRowsMutex.RUnlock()
	return len(fake.getBillableEventRowsArgsForCall)
}

func (fake *FakeEventStore) GetBillableEventRowsArgsForCall(i int) (context.Context, eventio.EventFilter) {
	fake.getBillableEventRowsMutex.RLock()
	defer fake.getBillableEventRowsMutex.RUnlock()
	return fake.getBillableEventRowsArgsForCall[i].ctx, fake.getBillableEventRowsArgsForCall[i].filter
}

func (fake *FakeEventStore) GetBillableEventRowsReturns(result1 eventio.BillableEventRows, result2 error) {
	fake.GetBillableEventRowsStub = nil
	fake.getBillableEventRowsReturns = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetBillableEventRowsReturnsOnCall(i int, result1 eventio.BillableEventRows, result2 error) {
	fake.GetBillableEventRowsStub = nil
	if fake.getBillableEventRowsReturnsOnCall == nil {
		fake.getBillableEventRowsReturnsOnCall = make(map[int]struct {
			result1 eventio.BillableEventRows
			result2 error
		})
	}
	fake.getBillableEventRowsReturnsOnCall[i] = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetBillableEvents(filter eventio.EventFilter) ([]eventio.BillableEvent, error) {
	fake.getBillableEventsMutex.Lock()
	ret, specificReturn := fake.getBillableEventsReturnsOnCall[len(fake.getBillableEventsArgsForCall)]
	fake.getBillableEventsArgsForCall = append(fake.getBillableEventsArgsForCall, struct {
		filter eventio.EventFilter
	}{filter})
	fake.recordInvocation("GetBillableEvents", []interface{}{filter})
	fake.getBillableEventsMutex.Unlock()
	if fake.GetBillableEventsStub != nil {
		return fake.GetBillableEventsStub(filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBillableEventsReturns.result1, fake.getBillableEventsReturns.result2
}

func (fake *FakeEventStore) GetBillableEventsCallCount() int {
	fake.getBillableEventsMutex.RLock()
	defer fake.getBillableEventsMutex.RUnlock()
	return len(fake.getBillableEventsArgsForCall)
}

func (fake *FakeEventStore) GetBillableEventsArgsForCall(i int) eventio.EventFilter {
	fake.getBillableEventsMutex.RLock()
	defer fake.getBillableEventsMutex.RUnlock()
	return fake.getBillableEventsArgsForCall[i].filter
}

func (fake *FakeEventStore) GetBillableEventsReturns(result1 []eventio.BillableEvent, result2 error) {
	fake.GetBillableEventsStub = nil
	fake.getBillableEventsReturns = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetBillableEventsReturnsOnCall(i int, result1 []eventio.BillableEvent, result2 error) {
	fake.GetBillableEventsStub = nil
	if fake.getBillableEventsReturnsOnCall == nil {
		fake.getBillableEventsReturnsOnCall = make(map[int]struct {
			result1 []eventio.BillableEvent
			result2 error
		})
	}
	fake.getBillableEventsReturnsOnCall[i] = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) ForecastBillableEventRows(ctx context.Context, events []eventio.UsageEvent, filter eventio.EventFilter) (eventio.BillableEventRows, error) {
	var eventsCopy []eventio.UsageEvent
	if events != nil {
		eventsCopy = make([]eventio.UsageEvent, len(events))
		copy(eventsCopy, events)
	}
	fake.forecastBillableEventRowsMutex.Lock()
	ret, specificReturn := fake.forecastBillableEventRowsReturnsOnCall[len(fake.forecastBillableEventRowsArgsForCall)]
	fake.forecastBillableEventRowsArgsForCall = append(fake.forecastBillableEventRowsArgsForCall, struct {
		ctx    context.Context
		events []eventio.UsageEvent
		filter eventio.EventFilter
	}{ctx, eventsCopy, filter})
	fake.recordInvocation("ForecastBillableEventRows", []interface{}{ctx, eventsCopy, filter})
	fake.forecastBillableEventRowsMutex.Unlock()
	if fake.ForecastBillableEventRowsStub != nil {
		return fake.ForecastBillableEventRowsStub(ctx, events, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.forecastBillableEventRowsReturns.result1, fake.forecastBillableEventRowsReturns.result2
}

func (fake *FakeEventStore) ForecastBillableEventRowsCallCount() int {
	fake.forecastBillableEventRowsMutex.RLock()
	defer fake.forecastBillableEventRowsMutex.RUnlock()
	return len(fake.forecastBillableEventRowsArgsForCall)
}

func (fake *FakeEventStore) ForecastBillableEventRowsArgsForCall(i int) (context.Context, []eventio.UsageEvent, eventio.EventFilter) {
	fake.forecastBillableEventRowsMutex.RLock()
	defer fake.forecastBillableEventRowsMutex.RUnlock()
	return fake.forecastBillableEventRowsArgsForCall[i].ctx, fake.forecastBillableEventRowsArgsForCall[i].events, fake.forecastBillableEventRowsArgsForCall[i].filter
}

func (fake *FakeEventStore) ForecastBillableEventRowsReturns(result1 eventio.BillableEventRows, result2 error) {
	fake.ForecastBillableEventRowsStub = nil
	fake.forecastBillableEventRowsReturns = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) ForecastBillableEventRowsReturnsOnCall(i int, result1 eventio.BillableEventRows, result2 error) {
	fake.ForecastBillableEventRowsStub = nil
	if fake.forecastBillableEventRowsReturnsOnCall == nil {
		fake.forecastBillableEventRowsReturnsOnCall = make(map[int]struct {
			result1 eventio.BillableEventRows
			result2 error
		})
	}
	fake.forecastBillableEventRowsReturnsOnCall[i] = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) ForecastBillableEvents(events []eventio.UsageEvent, filter eventio.EventFilter) ([]eventio.BillableEvent, error) {
	var eventsCopy []eventio.UsageEvent
	if events != nil {
		eventsCopy = make([]eventio.UsageEvent, len(events))
		copy(eventsCopy, events)
	}
	fake.forecastBillableEventsMutex.Lock()
	ret, specificReturn := fake.forecastBillableEventsReturnsOnCall[len(fake.forecastBillableEventsArgsForCall)]
	fake.forecastBillableEventsArgsForCall = append(fake.forecastBillableEventsArgsForCall, struct {
		events []eventio.UsageEvent
		filter eventio.EventFilter
	}{eventsCopy, filter})
	fake.recordInvocation("ForecastBillableEvents", []interface{}{eventsCopy, filter})
	fake.forecastBillableEventsMutex.Unlock()
	if fake.ForecastBillableEventsStub != nil {
		return fake.ForecastBillableEventsStub(events, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.forecastBillableEventsReturns.result1, fake.forecastBillableEventsReturns.result2
}

func (fake *FakeEventStore) ForecastBillableEventsCallCount() int {
	fake.forecastBillableEventsMutex.RLock()
	defer fake.forecastBillableEventsMutex.RUnlock()
	return len(fake.forecastBillableEventsArgsForCall)
}

func (fake *FakeEventStore) ForecastBillableEventsArgsForCall(i int) ([]eventio.UsageEvent, eventio.EventFilter) {
	fake.forecastBillableEventsMutex.RLock()
	defer fake.forecastBillableEventsMutex.RUnlock()
	return fake.forecastBillableEventsArgsForCall[i].events, fake.forecastBillableEventsArgsForCall[i].filter
}

func (fake *FakeEventStore) ForecastBillableEventsReturns(result1 []eventio.BillableEvent, result2 error) {
	fake.ForecastBillableEventsStub = nil
	fake.forecastBillableEventsReturns = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) ForecastBillableEventsReturnsOnCall(i int, result1 []eventio.BillableEvent, result2 error) {
	fake.ForecastBillableEventsStub = nil
	if fake.forecastBillableEventsReturnsOnCall == nil {
		fake.forecastBillableEventsReturnsOnCall = make(map[int]struct {
			result1 []eventio.BillableEvent
			result2 error
		})
	}
	fake.forecastBillableEventsReturnsOnCall[i] = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetConsolidatedBillableEventRows(ctx context.Context, filter eventio.EventFilter) (eventio.BillableEventRows, error) {
	fake.getConsolidatedBillableEventRowsMutex.Lock()
	ret, specificReturn := fake.getConsolidatedBillableEventRowsReturnsOnCall[len(fake.getConsolidatedBillableEventRowsArgsForCall)]
	fake.getConsolidatedBillableEventRowsArgsForCall = append(fake.getConsolidatedBillableEventRowsArgsForCall, struct {
		ctx    context.Context
		filter eventio.EventFilter
	}{ctx, filter})
	fake.recordInvocation("GetConsolidatedBillableEventRows", []interface{}{ctx, filter})
	fake.getConsolidatedBillableEventRowsMutex.Unlock()
	if fake.GetConsolidatedBillableEventRowsStub != nil {
		return fake.GetConsolidatedBillableEventRowsStub(ctx, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getConsolidatedBillableEventRowsReturns.result1, fake.getConsolidatedBillableEventRowsReturns.result2
}

func (fake *FakeEventStore) GetConsolidatedBillableEventRowsCallCount() int {
	fake.getConsolidatedBillableEventRowsMutex.RLock()
	defer fake.getConsolidatedBillableEventRowsMutex.RUnlock()
	return len(fake.getConsolidatedBillableEventRowsArgsForCall)
}

func (fake *FakeEventStore) GetConsolidatedBillableEventRowsArgsForCall(i int) (context.Context, eventio.EventFilter) {
	fake.getConsolidatedBillableEventRowsMutex.RLock()
	defer fake.getConsolidatedBillableEventRowsMutex.RUnlock()
	return fake.getConsolidatedBillableEventRowsArgsForCall[i].ctx, fake.getConsolidatedBillableEventRowsArgsForCall[i].filter
}

func (fake *FakeEventStore) GetConsolidatedBillableEventRowsReturns(result1 eventio.BillableEventRows, result2 error) {
	fake.GetConsolidatedBillableEventRowsStub = nil
	fake.getConsolidatedBillableEventRowsReturns = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetConsolidatedBillableEventRowsReturnsOnCall(i int, result1 eventio.BillableEventRows, result2 error) {
	fake.GetConsolidatedBillableEventRowsStub = nil
	if fake.getConsolidatedBillableEventRowsReturnsOnCall == nil {
		fake.getConsolidatedBillableEventRowsReturnsOnCall = make(map[int]struct {
			result1 eventio.BillableEventRows
			result2 error
		})
	}
	fake.getConsolidatedBillableEventRowsReturnsOnCall[i] = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetConsolidatedBillableEvents(filter eventio.EventFilter) ([]eventio.BillableEvent, error) {
	fake.getConsolidatedBillableEventsMutex.Lock()
	ret, specificReturn := fake.getConsolidatedBillableEventsReturnsOnCall[len(fake.getConsolidatedBillableEventsArgsForCall)]
	fake.getConsolidatedBillableEventsArgsForCall = append(fake.getConsolidatedBillableEventsArgsForCall, struct {
		filter eventio.EventFilter
	}{filter})
	fake.recordInvocation("GetConsolidatedBillableEvents", []interface{}{filter})
	fake.getConsolidatedBillableEventsMutex.Unlock()
	if fake.GetConsolidatedBillableEventsStub != nil {
		return fake.GetConsolidatedBillableEventsStub(filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getConsolidatedBillableEventsReturns.result1, fake.getConsolidatedBillableEventsReturns.result2
}

func (fake *FakeEventStore) GetConsolidatedBillableEventsCallCount() int {
	fake.getConsolidatedBillableEventsMutex.RLock()
	defer fake.getConsolidatedBillableEventsMutex.RUnlock()
	return len(fake.getConsolidatedBillableEventsArgsForCall)
}

func (fake *FakeEventStore) GetConsolidatedBillableEventsArgsForCall(i int) eventio.EventFilter {
	fake.getConsolidatedBillableEventsMutex.RLock()
	defer fake.getConsolidatedBillableEventsMutex.RUnlock()
	return fake.getConsolidatedBillableEventsArgsForCall[i].filter
}

func (fake *FakeEventStore) GetConsolidatedBillableEventsReturns(result1 []eventio.BillableEvent, result2 error) {
	fake.GetConsolidatedBillableEventsStub = nil
	fake.getConsolidatedBillableEventsReturns = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetConsolidatedBillableEventsReturnsOnCall(i int, result1 []eventio.BillableEvent, result2 error) {
	fake.GetConsolidatedBillableEventsStub = nil
	if fake.getConsolidatedBillableEventsReturnsOnCall == nil {
		fake.getConsolidatedBillableEventsReturnsOnCall = make(map[int]struct {
			result1 []eventio.BillableEvent
			result2 error
		})
	}
	fake.getConsolidatedBillableEventsReturnsOnCall[i] = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) IsRangeConsolidated(filter eventio.EventFilter) (bool, error) {
	fake.isRangeConsolidatedMutex.Lock()
	ret, specificReturn := fake.isRangeConsolidatedReturnsOnCall[len(fake.isRangeConsolidatedArgsForCall)]
	fake.isRangeConsolidatedArgsForCall = append(fake.isRangeConsolidatedArgsForCall, struct {
		filter eventio.EventFilter
	}{filter})
	fake.recordInvocation("IsRangeConsolidated", []interface{}{filter})
	fake.isRangeConsolidatedMutex.Unlock()
	if fake.IsRangeConsolidatedStub != nil {
		return fake.IsRangeConsolidatedStub(filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.isRangeConsolidatedReturns.result1, fake.isRangeConsolidatedReturns.result2
}

func (fake *FakeEventStore) IsRangeConsolidatedCallCount() int {
	fake.isRangeConsolidatedMutex.RLock()
	defer fake.isRangeConsolidatedMutex.RUnlock()
	return len(fake.isRangeConsolidatedArgsForCall)
}

func (fake *FakeEventStore) IsRangeConsolidatedArgsForCall(i int) eventio.EventFilter {
	fake.isRangeConsolidatedMutex.RLock()
	defer fake.isRangeConsolidatedMutex.RUnlock()
	return fake.isRangeConsolidatedArgsForCall[i].filter
}

func (fake *FakeEventStore) IsRangeConsolidatedReturns(result1 bool, result2 error) {
	fake.IsRangeConsolidatedStub = nil
	fake.isRangeConsolidatedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) IsRangeConsolidatedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.IsRangeConsolidatedStub = nil
	if fake.isRangeConsolidatedReturnsOnCall == nil {
		fake.isRangeConsolidatedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isRangeConsolidatedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) ConsolidateAll() error {
	fake.consolidateAllMutex.Lock()
	ret, specificReturn := fake.consolidateAllReturnsOnCall[len(fake.consolidateAllArgsForCall)]
	fake.consolidateAllArgsForCall = append(fake.consolidateAllArgsForCall, struct{}{})
	fake.recordInvocation("ConsolidateAll", []interface{}{})
	fake.consolidateAllMutex.Unlock()
	if fake.ConsolidateAllStub != nil {
		return fake.ConsolidateAllStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.consolidateAllReturns.result1
}

func (fake *FakeEventStore) ConsolidateAllCallCount() int {
	fake.consolidateAllMutex.RLock()
	defer fake.consolidateAllMutex.RUnlock()
	return len(fake.consolidateAllArgsForCall)
}

func (fake *FakeEventStore) ConsolidateAllReturns(result1 error) {
	fake.ConsolidateAllStub = nil
	fake.consolidateAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) ConsolidateAllReturnsOnCall(i int, result1 error) {
	fake.ConsolidateAllStub = nil
	if fake.consolidateAllReturnsOnCall == nil {
		fake.consolidateAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.consolidateAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) ConsolidateFullMonths(startAt string, endAt string) error {
	fake.consolidateFullMonthsMutex.Lock()
	ret, specificReturn := fake.consolidateFullMonthsReturnsOnCall[len(fake.consolidateFullMonthsArgsForCall)]
	fake.consolidateFullMonthsArgsForCall = append(fake.consolidateFullMonthsArgsForCall, struct {
		startAt string
		endAt   string
	}{startAt, endAt})
	fake.recordInvocation("ConsolidateFullMonths", []interface{}{startAt, endAt})
	fake.consolidateFullMonthsMutex.Unlock()
	if fake.ConsolidateFullMonthsStub != nil {
		return fake.ConsolidateFullMonthsStub(startAt, endAt)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.consolidateFullMonthsReturns.result1
}

func (fake *FakeEventStore) ConsolidateFullMonthsCallCount() int {
	fake.consolidateFullMonthsMutex.RLock()
	defer fake.consolidateFullMonthsMutex.RUnlock()
	return len(fake.consolidateFullMonthsArgsForCall)
}

func (fake *FakeEventStore) ConsolidateFullMonthsArgsForCall(i int) (string, string) {
	fake.consolidateFullMonthsMutex.RLock()
	defer fake.consolidateFullMonthsMutex.RUnlock()
	return fake.consolidateFullMonthsArgsForCall[i].startAt, fake.consolidateFullMonthsArgsForCall[i].endAt
}

func (fake *FakeEventStore) ConsolidateFullMonthsReturns(result1 error) {
	fake.ConsolidateFullMonthsStub = nil
	fake.consolidateFullMonthsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) ConsolidateFullMonthsReturnsOnCall(i int, result1 error) {
	fake.ConsolidateFullMonthsStub = nil
	if fake.consolidateFullMonthsReturnsOnCall == nil {
		fake.consolidateFullMonthsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.consolidateFullMonthsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) Consolidate(filter eventio.EventFilter) error {
	fake.consolidateMutex.Lock()
	ret, specificReturn := fake.consolidateReturnsOnCall[len(fake.consolidateArgsForCall)]
	fake.consolidateArgsForCall = append(fake.consolidateArgsForCall, struct {
		filter eventio.EventFilter
	}{filter})
	fake.recordInvocation("Consolidate", []interface{}{filter})
	fake.consolidateMutex.Unlock()
	if fake.ConsolidateStub != nil {
		return fake.ConsolidateStub(filter)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.consolidateReturns.result1
}

func (fake *FakeEventStore) ConsolidateCallCount() int {
	fake.consolidateMutex.RLock()
	defer fake.consolidateMutex.RUnlock()
	return len(fake.consolidateArgsForCall)
}

func (fake *FakeEventStore) ConsolidateArgsForCall(i int) eventio.EventFilter {
	fake.consolidateMutex.RLock()
	defer fake.consolidateMutex.RUnlock()
	return fake.consolidateArgsForCall[i].filter
}

func (fake *FakeEventStore) ConsolidateReturns(result1 error) {
	fake.ConsolidateStub = nil
	fake.consolidateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) ConsolidateReturnsOnCall(i int, result1 error) {
	fake.ConsolidateStub = nil
	if fake.consolidateReturnsOnCall == nil {
		fake.consolidateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.consolidateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	fake.refreshMutex.RLock()
	defer fake.refreshMutex.RUnlock()
	fake.getPricingPlansMutex.RLock()
	defer fake.getPricingPlansMutex.RUnlock()
	fake.storeEventsMutex.RLock()
	defer fake.storeEventsMutex.RUnlock()
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	fake.getUsageEventRowsMutex.RLock()
	defer fake.getUsageEventRowsMutex.RUnlock()
	fake.getUsageEventsMutex.RLock()
	defer fake.getUsageEventsMutex.RUnlock()
	fake.getBillableEventRowsMutex.RLock()
	defer fake.getBillableEventRowsMutex.RUnlock()
	fake.getBillableEventsMutex.RLock()
	defer fake.getBillableEventsMutex.RUnlock()
	fake.forecastBillableEventRowsMutex.RLock()
	defer fake.forecastBillableEventRowsMutex.RUnlock()
	fake.forecastBillableEventsMutex.RLock()
	defer fake.forecastBillableEventsMutex.RUnlock()
	fake.getConsolidatedBillableEventRowsMutex.RLock()
	defer fake.getConsolidatedBillableEventRowsMutex.RUnlock()
	fake.getConsolidatedBillableEventsMutex.RLock()
	defer fake.getConsolidatedBillableEventsMutex.RUnlock()
	fake.isRangeConsolidatedMutex.RLock()
	defer fake.isRangeConsolidatedMutex.RUnlock()
	fake.consolidateAllMutex.RLock()
	defer fake.consolidateAllMutex.RUnlock()
	fake.consolidateFullMonthsMutex.RLock()
	defer fake.consolidateFullMonthsMutex.RUnlock()
	fake.consolidateMutex.RLock()
	defer fake.consolidateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeEventStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ eventio.EventStore = new(FakeEventStore)
